    2ЛАБОРАТОРНАЯ РАБОТА 1.
    2ПРОСТЕЙШИЕ ТИПЫ ДАННЫХ. ФУНКЦИИ ВВОДА И ВЫВОДА

 ш1.0
                                          2│    0  1- "Си",
                                         2─┼─── 0   1японский иероглиф,
                                         2─┴─── 0   1означающий "мужчина"
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать понятия . 0:
 ш1.1
   - " 1система программирования 0",
    1-  0" 1программа 0",  " 1алфавит 0", 1   0" 1лексема 0",  " 1разделители 0", " 1объект в
 1языке C 0",  " 1объект в языке C++ 0", 1  0" 1атрибуты объекта 0", 1  0" 1l-value  0( 1име-
 1нующее выражение 0)", " 1идентификатор 0", " 1тип 0", " 1простейшие типы данных
 1языка C 0", 1   0" 1функции ввода-вывода 0", 1   0" 1спецификации  преобразования 0",
" 1выражение 0", 1  0" 1операция 0", 1  0" 1операнд 0", " 1приоритет операций 0", " 1побочный
 1эффект 0",  " 1продвижение  типов 0",  " 1таблица  приоритетов   операций 0",
" 1арифметические операции 0", " 1квин 0" 1. 0

 ш1.2
    _ 1Уметь . 0:
 ш1.1
   - осуществлять ввод и вывод значений указанных типов;
   - применять арифметические операции к данным указанных типов.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
              3Несколько слов о языке программирования C

 ш1.0
                   1- Во всяком случае, я не Ада! - сказала она реши-
                   1тельно. - У неё волосы вьются, а у меня нет! 0
                                                            1Л.Кэррол
 ш1.2

   Под  1системным программированием 2  0понимают деятельность по  разра-
ботке  системных программ,  составляющих центральную и самую важную
часть всей программной "начинки" любого компьютера.
   Системным программированием занимаются мастера из мастеров.  Не-
доступность их деятельности для всеобщего понимания составляет  су-
щественную часть их профессиональной гордости.  Их взгляды на науку
программирования зачастую граничат с экстремизмом.  То,  что  ценит
начинающий  программист в наиболее популярных языках программирова-
ния - доступность,  ясность, гарантии от ошибочных действий, - сис-
темному программисту кажутся излишествами и,  пожалуй, даже раздра-
жают.  Зачем мастеру предохранители от ошибок,  если "он и  так  не
ошибается"?  Зачем  ему предельная ясность программных конструкций,
если он и без всяких подсказок способен проследить выполнение прог-
раммы до элементарных действий, протекающих глубоко в недрах компь-
ютера, и хотел бы организовать эти действия не наиболее понятно для
новичка, а наиболее эффективно? Выжать из компьютера максимум того,
на что он способен,  - под знаком таких  соображений  и  создавался
язык C системными программистами для своих собственных нужд.  Это и
сделало его столь эффективным и столь неординарным.
   Язык C представляет собой удачный компромисс между желанием рас-
полагать возможностями,  которые обычно предоставляют  программисту
"понятные"  и  "удобные" языки высокого уровня и стремлением эффек-
тивно использовать особенности компьютера.  В некотором смысле язык
C - самый универсальный, т.к. кроме набора средств, присущих языкам
программирования высокого уровня (структурность, модульность, опре-
деляемые типы данных),  в него включены средства для программирова-
ния "почти" на уровне ассемблера (использование указателей, битовые
операции). Однако такие мощные средства требуют от программиста ос-
торожности, аккуратности и хорошего знания языка со всеми его преи-
муществами и недостатками.
    3Замечания 0.
 ш1.1
    21.  0Буква "C" - это третья буква английского алфавита  (читается:
" 1си 0"). Это наименование говорит о чувстве юмора у создателей языка,
т.к.  его предшественником был язык B,  а B - это вторая буква анг-
лийского алфавита (читается: " 1би 0").
    22.  0Приведём перевод, на наш взгляд, интересной заметки из колон-
ки редактора компьютерного журнала Софтпанорама, 1992, 4 (28) (пер.
Д.Кохманюка).
                         1Уважаемые коллеги!
        1Создатели С и UNIX признают, что разыграли весь мир!
   В заявлении,  потрясшем весь компьютерный мир, Кен Томпсон, Ден-
нис Ричи и Брайан Керниган признали,  что операционная система UNIX
и язык программирования С, созданные ими - тщательно спланированный
первоапрельский розыгрыш, "продержавшийся" более 20 лет.
   Выступая на последнем конгрессе разработчиков программного обес-
печения для ОС ДЕМОС (UNIX World Software Development Forum), Томп-
сон признал следующее:  "В 1969 году AT&T завершила работу над про-
ектом  операционной системы Multics (известная операционная система
60-х).  Брайан и я только что начали работу  с  ранней  реализацией
Паскаля,  разработанной в лаборатории проф.  Н.Вирта в Швейцарии, и
находились под впечатлением элегантности,  простоты  и  мощи  этого
языка.  Деннис как раз прочитал "Уставший от колец", весёлую сатиру
на знаменитую трилогию Толкина "Властелин колец". Ради шутки мы ре-
шили написать пародии на среду Multics и Pascal. Деннис и я отвеча-
ли за операционную среду. Глядя на Multics, мы спроектировали новую
систему  настолько сложной и запутанной,  чтобы максимально "испор-
тить жизнь" рядовым пользователям,  назвали ее UNIX как пародию  на
Multics, добавив много других достаточно рискованных аналогий.
   Затем Деннис и Брайан разработали по-настоящему извращённый диа-
лект языка Pascal,  назвав его "A". Когда мы обнаружили, что другие
действительно пытаются писать программы на A,  мы  быстро  добавили
ещё парочку хитрых "примочек" ( 1cryptic features 0), создав B, BCPL и,
наконец,  С. Мы остановились, добившись успешной компиляции следую-
щего программного фрагмента:
 ш1.0

   for(;P("\n");R--,P("│"))for(e=C;e--;P("_"+(*u++/8)%2))
   P("│"+(*u/4)%2);

 ш1.1
   Мы не могли даже представить, что современные программисты будут
пытаться использовать язык,  допускающий подобный оператор! Мы даже
собирались продать все это в Советский Союз, чтобы отбросить разви-
тие их  computer science на 20 лет назад.  Представьте наше удивле-
ние,  когда AT&T, а также другие американские корпорации начали пы-
таться использовать UNIX и С! Более 20 лет ушло на то, чтобы приоб-
рести достаточный опыт для создания хоть немного полезных  приложе-
ний с использованием этой технологической пародии 60-х. Мы были по-
ражены упорством и целеустремленностью (если не  чувством  здравого
смысла) типичного программиста, использующего UNIX и/или С. В любом
случае Брайан, Деннис и я в течение последних лет работали исключи-
тельно на  языке  Pascal  в  среде Apple Macintosh и чувствуем себя
по-настоящему виноватыми в  том  хаосе,  путанице  и  действительно
скверном программировании,  причиной которых явилась наша неудачная
шутка столько лет тому назад".
   Большинство поставщиков  версий UNIX и С,  включая AT&T,  Micro-
soft, Hewlett-Packard, GTE, NCR, DEC, отказались комментировать это
выступление.  Borland International,  ведущий производитель инстру-
ментальных средств для Pascal и С, включая популярные TURBO Pascal,
TURBO C и TURBO C++,  заявил, что они давно подозревали это и будут
продолжать улучшать свои разработки для языка  Pascal  и  прекратят
дальнейшие усилия по развитию С. Официальный представитель IBM раз-
разился безудержным хохотом и был вынужден отменить спешно  собран-
ную конференцию о судьбе RS-6000,  заявив,  что "VM появится в бли-
жайшее время".  В  непонятном  аудитории  кратком  сообщении  проф.
Н.Вирт, отец языков Pascal, Modula2 и Oberon, сказал лишь, что нек-
то P.T.Barnum был прав.
   Кстати, из обычно совершенно надёжных источников стало известно,
что подобное признание возможно скоро последует от  Вильяма  Гейтса
относительно MS-DOS и Windows. Не случайно, вышеупомянутый предста-
витель IBM уже начал отрицать, что Виртуальная Машина (VM) является
созданной для внутреннего употребления аналогичной шуткой,  вырвав-
шейся наружу.
    23. 0 Приведём краткую информацию о создателях языков C и C++.
    _ 1Ричи Деннис . 0 (род. 9.09.1941,  Маунт-Вернон,  Нью-Йорк) -  амери-
канский программист,  создатель  операционной  системы UNIX и языка
программирования C.
    _ 1Томпсон Кеннет . 0  (род. 4.02.1943,  Новый  Орлеан) -  американский
программист, создатель операционной системы UNIX и языка программи-
рования C.
    _ 1Страуструп Бьорн . 0 (род. 1950, Ааргус, Дания) - американский прог-
раммист, создатель языка программирования C++.

 ш1.2
    3Замечание 0.
 ш1.1
   По мотивам программного фрагмента, упомянутого выше, мы написали
работающую программу (см. Демонстрационный пример №0).
 ш1.2

                 3Понятие о 0  3системе программирования

 ш1.0
                                             1- Сказать об этой драме
                                             1Какими мне словами?
                                             1- А ты начни писать.
                                             1Слова польются сами.
                                             1- А как, скажи, начать?
                                             1Какими
                                             1Мне
                                             1Словами?
                                                          1В.Казанцев
 ш1.2

    _ 1Система программирования . 2  0- это часть базового программного обес-
печения, поддерживающая процесс программирования на некотором языке
программирования. Система программирования включает в себя:
 ш1.1
   (1)  1редактор  текстов 0  для создания текста программ и ввода их в
компьютер;
   (2)  1компилятор 0  для перевода программ с входного языка на машин-
ный язык или  1интерпретатор 0 для непосредственного  исполнения  прог-
рамм на входном языке системы программирования;
   3)  1отладчик 0 для ускорения нахождения ошибок в программах;
   4)  1библиотеку периода компиляции 0,  содержащую подпрограммы, объ-
единяемые с главной программой в процессе работы компилятора;
   5)  1библиотеку периода исполнения 0, содержащую подпрограммы на ма-
шинном языке, вызываемые при исполнении составляемой программы;
   6)  1монитор 0, организующий функционирование системы программирова-
ния в целом.

 ш1.2
   Чтобы дать Вам первое представление о процессе создания програм-
мы,  приведём упрощённую схему того, что необходимо сделать - начи-
ная от написания текста программы и заканчивая её выполнением:
 ш1.1

   (1) воспользуйтесь редактором текстов для написания программы на
языке C.  Файл, содержащий программу, может иметь любое имя, правда
с тем условием,  что оно должно удовлетворять ограничениям на имя в
данной операционной системе и иметь расширение .c;
   (2) осуществите компиляцию Вашей программы с помощью  компилято-
ра, который проведёт проверку правильности программы и,  если обна-
ружит ошибки,  то выдаст сообщение об этом; в противном случае ком-
пилятор  выполнит перевод программы во внутренний язык компьютера и
поместит результат в новый файл;
   (3) "выполните"  этот файл с помощью средств операционной систе-
мы.

 ш1.2
   Мы будем пользоваться системой программирования Borland C v3.1.
    _ 1Советы . 0 [Дейтел,Дейтел,2002,с.56].
 ш1.1
    21. 0 Читайте руководства пользователя по версиям языка C,  с кото-
рыми работаете. Частое обращение к ним позволит узнать много полез-
ного об особенностях языка C и поможет их корректно использовать.
    22.  1Хорошими  учителями 0 являются  _ 1компьютер . 0 и  _ 1компилятор . 0.  Если Вы
не уверены в том, как работает та или иная конструкция C, то следу-
ет написать пробную программу, откомпилировать, запустить её и пос-
мотреть, что получится.
 ш1.2

                 3Программа. 0  3Алфавит языка С. Лексемы

 ш1.0
                  1Буквы, которые вы используете для обозначения  об-
                  1суждаемых понятий,  заслуживают тщательных предва-
                  1рительных размышлений...  Плохая система обозначе-
                  1ний может сделать хорошее изложение плохим, а пло-
                  1хое - еще ухудшить;  решения об обозначениях, при-
                  1нимаемые наспех посреди фразы, почти наверняка бу-
                  1дут плохими. 0
                        1П.Р.Халмош. Как писать математические тексты
 ш1.2

    _ 1Программа на языке . 0  1С 0 - это  1правильно построенное слово в алфави-
 1те языка С 0,  которое содержит шесть базовых элементов языка:  1разде-
 1лители 0,  1константы 0,  1идентификаторы 0,  1служебные слова 0,  1знаки операций 0,
 1метки 0.
    _ 1Алфавит языка .  С 0  - это множество,  состоящее из следующих букв,
которые называются  _ 1основными символами . 0:
   (1)  _ 1прописные и 0  1строчные латинские буквы . 0:
       A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
       a b c d e f g h i j k l m n o p q r s t u v w x y z;
   (2)  _ 1арабские цифры . 0: 0 1 2 3 4 5 6 7 8 9;
   (3)  _ 1специальные символы . 0:
 ш1.0

        пробел;
      2_ 0  подчеркивание;
     (  левая круглая скобка;
     )  правая круглая скобка;
     [  левая квадратная скобка;
     ]  правая квадратная скобка;
     {  левая фигурная (операторная) скобка;
     }  правая фигурная (операторная) скобка;
     =  равно;
     <  меньше;
     >  больше;
     +  плюс;
     -  минус;
     *  звездочка;
     /  дробная черта;
     \  обратная дробная черта;
     %  процент;
     !  восклицательный знак;
     ?  вопросительный знак;
     #  номер;
     .  точка;
     ,  запятая;
     ;  точка с запятой;
     :  двоеточие;
     '  апостроф;
     "  кавычки;
     &  коммерческое "и" (или " 1амперсенд 0");
     ^  стрелка вверх;
     |  вертикальная черта;
     ~  черта сверху (или " 1тильда 0").

   (4)  _ 1управляющие символы . 0:

    \n перевод строки и возврат каретки (" 3n 1ewline 0");
    \t горизонтальная табуляция (" 1horisontal  3t 1ab 0");
    \b возврат на один символ (" 3b 1ackspace 0");
    \r возврат каретки (" 1carriage  3r 1eturn 0");
    \f перевод формата (" 3f 1orm feed 0").

 ш1.2
   Алфавит языка С расширен  1буквами русского алфавита 0 (прописными и
строчными),  которые  могут  использоваться только в комментариях и
константах (символьных и строковых).
    _ 1Лексемами . 0 называются  последовательности символов алфавита (раз-
делители,  идентификаторы,  служебные слова,  константы,  составные
знаки  операций).  Лексемы разделяются пробелами и другими неграфи-
ческими символами языка.
                             3Разделители
    _ 1Разделители . 0 служат для выделения составляющих языка.  В качестве
разделителей в языке C используются:
 ш1.1
   -  1фигурные скобки 0 ({, }) для выделения  1тела функции 0 и  1блока 0;
   -  1круглые скобки 0 для группирования элементов в выражениях;
   -  1двойные кавычки 0 (") для выделения символьной строки;
   -  1апострофы 0 (') для выделения символа;
   -  1запятая 0 (,) для разделения элементов;
   -  1точка с запятой 0 (;) для ограничения простого оператора;
   - символы /* и */ для обозначения соответственно начала и  конца
комментариев.

 ш1.2
    3Замечание 0 ( 1о комментариях 0).
 ш1.1
   Использование комментариев облегчает процесс понимания программы
любым программистом (включая Вас самих).  Большим удобством при на-
писании  комментариев является возможность располагать их на той же
строке,  что и операции,  которые они поясняют. Длинный комментарий
может  помещаться  на  отдельной строке или даже занимать несколько
строк.  Компилятор "игнорирует" все символы, находящиеся между лек-
семой /*,  указывающей  1начало комментария 0, и лексемой */, указываю-
щей  1конец комментария 0.
 ш1.2

               3Понятие "объект". 0  3Понятие "переменная"

 ш1.0
                  1Понятие  _переменной . представляет  собой  абстракцию
                  1соответствующего  текущего  значения.  Я слышал (к
                  1большому сожалению не могу вспомнить от кого) мне-
                  1ние,  что, как только человек осознал, как в прог-
                  1раммировании  используются  переменные,  он  понял
                  1сущность программирования. 0
                                                          1Э.Дейкстра
 ш1.2

    2Определение 0 ( 1важное 0).
 ш1.1
    2(1)  _ 1Объект в языке . C 0 - это поименованная область памяти,  содер-
жимое которой может быть изменено.
    2(2) 0  _ 1Объект в языке . C++ 0 - это экземпляр класса.

 ш1.2
   Говоря проще, " 1объект 0" - это общий термин для всего того, на что
можно ссылаться и что можно обрабатывать.  Другими словами,   1объект
представляет  собой "контейнер" для хранения значений данных,  т.е.
то место, где эти значения хранятся и откуда они затем извлекаются.
   Объект характеризуется набором характеристик, называемых  _ 1атрибу-
 _ 1тами . 0 (самым важным из которых является  1тип данных 0).  Атрибуты опре-
деляют количество и тип значений,  которые могут содержаться в объ-
екте, а также определяют логическую организацию этих значений.
   Перечислим [Пратт,Зелковиц,2002,с.183;Дейтел,Дейтел,2002,с.193])
наиболее важные  _ 1атрибуты объекта . 0:
 ш1.1
   (1)  _ 1идентификатор . 0 ( _ 1имя . 0);
   (2)  _ 1тип . 0 (этот атрибут ассоциирует объект со множеством значений,
которые могут содержаться в этом объекте);
   (3)  _ 1значение . 0;
   (4)  _ 1класс памяти . 0, который в свою очередь определяет:
    -  _ 1область действия . 0, которая характеризует возможность обращения
к объекту из различных частей программы (некоторые объекты доступны
во всей программе, другие - только в отдельных её частях);
    -  _ 1период хранения . 0 - это время, в течение которого данный объект
существует в памяти (некоторые объекты существуют  короткое  время,
некоторые неоднократно создаются и разрушаются, другие существуют в
течение всего времени выполнения программы);
    -  _ 1тип компоновки . 0,  который определяется для программ, состоящих
из нескольких исходных файлов,  объединяемых  на  этапе  компиляции
(эта  характеристика  показывает,  известен  ли  программный объект
только в текущем исходном файле или в любом исходном файле с  соот-
ветствующими объявлениями).

 ш1.2
   Важнейшим программным объектом является  _ 1переменная . 0.
    2Определение 0 (по [Жешке,1994,с.114]).
 ш1.1
    _ 1Именующее выражение . 0  (или  _ 1lvalue . 0) - это выражение,  используемое
для обозначения объекта. Именующее выражение "пригодно" к использо-
ванию со знаком & ( 1операция адресации 0).
   Наиболее широко  используемыми формами именующих выражений явля-
ются имена переменных и выражения вида *p,  где p  -  указатель  на
объект.  Знаки операций [], * и -> всегда порождают именующее выра-
жение; это же обычно делает . (точка) как знак операции.
 ш1.2

                              3Константы

 ш1.0
                  1Преимущества десятичной системы не математические,
                  1а  зоологические.  Если  бы у нас на руках было не
                  1десять пальцев,  а восемь, то человечество пользо-
                  1валось бы восьмеричной системой. 0
                                                           1Н.Н.Лузин
 ш1.2

    _ 1Константы . 0 - это неизменяемые объекты языка программирования.
   Константы могут быть  1целые 0,   1длинные целые 0,   1с плавающей точкой 0,
 1символьные 0,  1строковые 0,  1перечислимые 0.
    21.  _ 1Целые числовые константы . 0 могут быть  1десятичными 0,  1восьмеричны-
 1ми 0,  1шестнадцатеричными 0.
   Начальный нуль "0" в записи целой числовой  константы  указывает
на  1восьмеричную константу 0,  а стоящие впереди записи целой числовой
константы символы  "0X"  (или  "0x")  определяют   1шестнадцатеричную
 1константу 0. Например:
 ш1.1
   31   - десятичная константа,
   037  - восьмеричная константа,
   0X1  - шестнадцатеричная константа,
   0x2F - шестнадцатеричная константа.

 ш1.2
    22.  _ 1Длинные целые константы . 0  явно  определяются буквой l (или L),
расположенной после целой константы. Например:
 ш1.1
   10l   - длинная десятичная константа,
   0627L - длинная восьмеричная константа,
   0XABl - длинная шестнадцатеричная константа.

 ш1.2
    23.  _ 1Константы  с плавающей точкой . 0 представимы числами с плавающей
точкой двойной точности и состоят из следующих частей:
 ш1.1
   - целой части (это последовательность цифр);
   - десятичной точки;
   - дробной части (это последовательность цифр);
   - символа экспоненты e или E;
   - экспоненты в виде целой константы (возможно, со знаком).

 ш1.2
   Любая часть (но не обе сразу) из нижеследующих  пар  может  быть
опущена: целая или дробная, десятичная точка или символ e(E) и экс-
понента в виде целой константы.
   Например: 455. , 4.563 , 2.5E4 , 0E0 , .12E-2
   Константы с плавающей точкой представляются только в  десятичной
системе счисления.
    24.  _ 1Символьные константы . 0 применяются для обозначения одного  сим-
вола  алфавита языка.  Символьная константа представляет собой один
символ алфавита, заключённый в  1апострофы 0.
   Значением символьной константы является целая числовая  констан-
та, называемая  _ 1кодом данного символа . 0.
   Для некоторых символов принято специальное обозначение с помощью
символа " 2\ 0" ( 1экранирующей дробной черты 0).
    25.  _ 1Строковые константы . 0 ( _ 1символьные 0  1строки . 0) представляются после-
довательностью символов, заключённой в двойные кавычки. Например:
 ш1.0

   "A", "строка", "string"

 ш1.2
   Символ кавычки  (") может быть включен в символьную строку с по-
мощью  1управляющей последовательности 0,  т.е.  совокупности  символов
\". Например:
 ш1.0

   "Это выделение \"кавычки\""

 ш1.2
   Длинная строковая константа может быть продолжена  на  следующую
экранную строку с помощью символа \. 2  0Например:
 ш1.0

   "Очень большие \
раки"

 ш1.2
   Строки могут содержать управляющие символы. Например, при выводе
строки:
 ш1.0

   "Первая строка\nВторая строка"

будет получен следующий результат:

   Первая строка
   Вторая строка

 ш1.2
    26. 0  _ 1Перечислимые константы . 0 трактуются как целые константы.
    3Замечание 0 [Прата,2003,с.985-986].
 ш1.1
   На двух вычислительных платформах, в которых используется двоич-
ное представление целых чисел, одно и то же число может быть предс-
тавлено по-разному.  В машинах, работающих на платформе Intel, нап-
ример,  байты хранятся при помощи архитектуры  _ 1Little Endian . 0,  в  то
время   как   на  компьютерах  Motorola,  DEC  Alpha,  а  также  на
MIPS-компьютерах с сокращённым набором команд, для этого применяет-
ся схема  _ 1Big Endian . 0 (отметим,  что последние две системы могут быть
настроены на использование другой схемы).
   Термины " 1Big Endian 0" и " 1Little Endian 0" произошли от "Big End In"
и "Little End In"  -  определение  порядка  хранения  байтов  слова
(обычно двухбайтового элемента). На компьютерах Intel (Little Endi-
an) байт младшего разряда хранится первым.  Это означает, что шест-
надцатеричное значение,  такое как 0xABCD, в памяти будет храниться
как (0xCD 0xAB).
    1Разработчик программного обеспечения должен знать, какой порядок
 1хранения байтов слова используется на платформе, с которой он рабо-
 1тает 0.  Этот порядок,  помимо всего прочего, влияет на интерпретацию
данных, передаваемых по сети, а также на сохранение данных в двоич-
ных файлах.
   В приведённых примерах двухбайтовый фрагмент  памяти  0xABCD  на
компьютере,  поддерживающем архитектуру Little Endian, будет предс-
тавлять десятичное число 52651, а на компьютере, поддерживающем ар-
хитектуру Big Endian, - 436981.

 ш1.2
                           3Идентификаторы
    _ 1Идентификатор . 2  0- это последовательность латинских  букв,  цифр  и
символа " 1подчеркивание 0" (_),  начинающаяся с буквы или символа "_",
при этом прописные и строчные латинские буквы считаются  1различными 0.
   По сложившейся традиции,  принятой в языке C,  в идентификаторах
используют  1только строчные буквы 0, а в именах символических констант
и макроименах -  1только прописные буквы 0 (говорят,  что язык C тради-
ционно является "языком нижнего регистра").
   Символ "_" применяется для написания "составного" идентификатора
(таким образом, идентификатор может начинаться с символа "_").
    2Примеры 0 ( 1идентификаторов 0).
 ш1.1
    21.  0was, a1b, very_long_identifier - идентификаторы.
    22. 0 Идентификаторы verylongidentifier и VeryLongIdentifier  явля-
ются различными.

 ш1.2
   Программы значительно легче читать и понимать,  если идентифика-
торы имеют для человека определённый смысл. В языке C в идентифика-
торах запрещено использовать русские буквы,  поэтому возникает воп-
рос,  как же добиться осмысленности имен?  Обычно программисты  ис-
пользуют  слова  английского языка,  но можно просто писать русские
слова латинскими буквами (т.е. использовать  1транслитерацию 0).
   Например, идентификаторы  nomer и svet выглядят несколько непри-
вычно, но вполне понятно, какие объекты они обозначают.

                           3Служебные слова

 ш1.0
                               1Главным образом он любил слова, обыч-
                               1но не встречающиеся в словарях.
                                                      1Г.К.Лихтенберг
 ш1.2

    _ 1Служебными . 0 ( _ 1ключевыми . 0)  _ 1словами языка . C 0 будем называть  следующие
лексемы, которые запрещено использовать в качестве идентификаторов:
 ш1.0

   ┌─────────────┬───────────────┬───────────┬───────────┐
   │  3Типы данных 0 │  3Классы памяти 0 │  3Операторы 0 │   3Функции 0  │
   ╞═════════════╪═══════════════╪═══════════╪═══════════╡
   │ char        │ auto          │ break     │ nonrec    │
   │ double      │ extern        │ case      │ recursive │
   │ enum        │ register      │ continue  │ sizeof    │
   │ float       │ static        │ default   │ typedef   │
   │ int         │               │ do        │           │
   │ long        │               │ else      │           │
   │ short       │               │ for       │           │
   │ struct      │               │ goto      │           │
   │ union       │               │ if        │           │
   │ unsigned    │               │ return    │           │
   │ void        │               │ switch    │           │
   │             │               │ while     │           │
   └─────────────┴───────────────┴───────────┴───────────┘

 ш1.2
    3Замечание 0.
 ш1.1
   Перечислим ключевые слова C++,  не  входящие  в  состав  средств
Стандарта языка C. Предполагая использование исходных текстов прог-
рамм, написанных на языке C, в среде программирования на языке C++,
Вам  следует избегать применения в качестве идентификаторов следую-
щих имён: asm, catch, class, delete, friend, inline, new, operator,
private, protected, public, template, this, throw, try, virtual.
 ш1.2

                       3Понятие типа в языке С

 ш1.0
                1А потом он подумал:  "Все-таки это очень хорошенький
                1горшочек, хотя в нём и нет меду. Если я его как сле-
                1дует вымою и попрошу кого-нибудь  написать  на  нем:
                1"Поздравляю  с  днем рождения",  Иа сможет держать в
                1нем всё что хочешь. Это будет полезная вещь 0! 1"
                                   1А.А.Милн, Винни-Пух и все-все-все
 ш1.2

   Все обрабатываемые компьютером данные,  в конечном счёте, разби-
ваются на отдельные биты. Однако написание программ, обрабатывающих
исключительно биты, слишком трудоёмкое занятие.  1Типы 0 позволяют ука-
зывать, как будут использоваться определённые наборы битов.
    2Определение 0 ( 1с точки зрения математика 0).
 ш1.1
    _ 1Тип .  0- это  1множество 0  1значений 0,  которые может принимать объект, и
 1множество 0  1операций 0, в которых он может участвовать.

 ш1.2
    2Определение 0 ( 1с точки зрения конструктивного математика 0).
 ш1.1
    _ 1Тип . 0 - множество значений, которые может принимать объект, и мно-
жество конструктивно определённых операций над значениями объекта.

 ш1.2
    2Определение 0 ( 1с точки зрения программиста 0).
 ш1.1
    _ 1Тип . 0 - это атрибут объекта,  определяющий: (1) множество допусти-
мых значений, которые может иметь тот или иной объект; (2) множест-
во допустимых операций,  которые применимы к допустимым  значениям;
(3) формат внутреннего представления данных в памяти компьютера.

 ш1.2
   Говорят, что   _ 1в языке . C  _типы связаны с переменными . 0 (другими сло-
вами, говорят, что " 1каждая переменная должна быть описана 0").
   В описании указывается тип переменной,  следовательно, определя-
ются допустимые для него значения и операции.
   Например, пусть переменная имеет числовой тип. Это означает, что
её значением может быть только  1число 0,  и что с его значением  можно
производить арифметические операции (но нельзя,  например,  опреде-
лить количество символов, содержащихся в значении).
   Более точно,  с каждой переменной (а, следовательно, и с иденти-
фикатором) в языке C связана некоторая область памяти. Тип перемен-
ной задает размер этой области памяти, способ расшифровки её содер-
жимого, допустимые преобразования над значением содержимого.
   Одна и  та  же  последовательность нулей и единиц в памяти может
быть расшифрована разными способами, например, как число или текст.
В зависимости от "расшифровки" содержимого некоторой области памяти
определяется допустимость выполнения над ним тех или иных операций.
При  программировании  на  машинном языке за правильность всех этих
действий отвечает программист. При работе с языками высокого уровня
это происходит автоматически именно благодаря использованию типов.

                   3Простейшие типы данных языка C

 ш1.0
               1С - это язык с сильной типизацией и слабым контролем.
                                                             1Д.Ритчи
 ш1.2

    _ 1Простейшие типы данных языка . C 0 -  это  типы  данных,  обладающие
следующим свойством:  объекты этих типов не имеют внутренней струк-
туры и содержат лишь одно неделимое значение.
   Перечислим простейшие типы.
    21. 0  _ 1Тип "целый" . 0, имя типа в языке C:
 ш1.0

   int.

 ш1.2
   Значениями этого типа являются целые числа из некоторого ограни-
ченного диапазона.  Диапазон определяется размером ячейки для типа.
Целое число занимает  _ 1два байта . 0,  поэтому диапазон допустимых значе-
ний: [-32768,32767].
   Имеются служебные слова, которые можно использовать с типом int.
    2(а) 0  _ 1Тип "короткое целое" . 0, имя типа в языке C:
 ш1.0

   short int.

 ш1.2
   Величина типа short int занимает в памяти  _ 1два байта . 0, поэтому ди-
апазоном её значений является [-32768,32767].
   Данные типа  short int и типа int имеют одинаковое представление
в компьютере.
   Служебное слово int в имени данного типа может быть опущено.
    2(б) 0  _ 1Тип "целое без знака" . 0, имя типа в языке C:
 ш1.0

   unsigned int.

 ш1.2
   Величина типа unsigned int занимает в памяти  _ 1два байта . 0,  поэтому
диапазоном её значений является [0,65535].
   Служебное слово int в имени данного типа может быть опущено.
   Использование типа unsigned предпочтительнее,  чем использование
типа int.
    2(в) 0  _ 1Тип "длинное целое" . 0, имя типа в языке C: 1
 ш1.0

   long int.

 ш1.2
   Величина этого типа занимает в памяти  _ 1четыре байта . 0.
    22. 0  _ 1Тип "символьное" . 0, имя типа: 1
 ш1.0

   char 2  0(от англ.  1character 0).

 ш1.2
   Величина этого типа занимает  _ 1один байт . 0 в памяти компьютера.
   В памяти фактически хранится не символ,  а целое число 1  0(от 0  до
255),  называемое   _ 1кодом символа . 0.  В специальных таблицах кодировки
указываются все допустимые символы и коды, соответствующие им.
   По умолчанию тип char интерпретируется как тип unsigned.
   Имеются служебные слова, которые можно использовать с типом char.
    2(а) 0  _ 1Тип "короткое символьное" . 0, имя типа:
 ш1.0

   short char.

 ш1.2
   Величина этого типа занимает  _ 1один байт . 0 в памяти компьютера.
    2(б) 0  _ 1Тип "символьное без знака" . 0, имя типа:
 ш1.0

   unsigned char.

 ш1.2
   Величина этого типа занимает  _ 1один байт . 0 в памяти компьютера.
    2(в) 0  _ 1Тип "длинное символьное" . 0, имя типа:
 ш1.0

   long char.

 ш1.2
    3Замечание 0.
 ш1.1
   В языке  C  разрешается  использовать тип char как числовой тип,
т.е. производить "арифметические" операции с кодом символа.

 ш1.2
    23. 0  _ 1Тип "вещественный" . 0, имя типа:
 ш1.0

   float.

 ш1.2
   Величина этого типа занимает  _ 1четыре байта . 0 в памяти компьютера.
   Значениями этого  типа являются  1рациональные числа 0 (!) из диапа-
зона: 3.4 77 010 5-38 7_ 03.4 77 010 538 0.
   Для чего нужно различать типы int и float? Нельзя ли считать це-
лые числа частным случаем чисел типа float и обойтись без типа int?
   Дело в том, что числа этих типов по-разному представлены в памя-
ти компьютере:  объекты типа int занимают  меньше  памяти,  поэтому
операции над ними выполняются быстрее.
    24. 0  _ 1Тип "с плавающей точкой" . 0 (или " 1двойной точности" 0), имя типа:
 ш1.0

   double.

 ш1.2
   Величина этого типа занимает  _ 1восемь байтов . 0 в памяти компьютера.
   Значениями этого типа являются  1рациональные числа 0 (!) из  диапа-
зона: 1.7 77 010 5-308 7_ 01.7 77 010 5308 0.
    25. 0  _ 1Тип "длинное с плавающей точкой" . 0, имя типа:
 ш1.0

   long double.

 ш1.2
   Величина этого типа занимает  _ 1десять байтов . 0 в памяти компьютера.
   Приведём сводную таблицу,  в которой представлены диапазоны зна-
чений чисел различных типов в языке программирования C:
 ш1.0

 ┌──────────────────┬──────────────────┬──────────────────────────┐
 │        3Тип 0        │   3Размер памяти 5    0│ 5  0    3Диапазон возможных 0    │
 │                  │     3в байтах 0      │          3значений 0        5  0 │
 ╞══════════════════╪══════════════════╪══════════════════════════╡
 │short int         │          32 0        │      -32768 7, 0n 7, 032767      │
 ├──────────────────┼──────────────────┼──────────────────────────┤
 │unsigned short int│          32 0        │         0 7, 0n 7, 065535        │
 ├──────────────────┼──────────────────┼──────────────────────────┤
 │long int          │          34 0        │ -2147483648 7, 0n 7, 02147483647 │
 ├──────────────────┼──────────────────┼──────────────────────────┤
 │unsigned long int │          34 0        │       0 7, 0n 7, 04294967295     │
  5╞══════════════════╪══════════════════╪══════════════════════════╡
 │                  │  34 0 байта=32 бита: │  Приблизительно         5  0 │
  5│ 0float 5             │ 0  1 - знак,       │                          │
 │                  │  8 - экспонента, │  1.17 77 010 5-38 0<x<3.4 77 010 538 0   5  0│
 │                  │  23 - мантисса   │                          │
 ├──────────────────┼──────────────────┼──────────────────────────┤
 │                  │  38 0 байтов=64 бита:│   Приблизительно         │
 │double            │  1 - знак,       │                          │
 │                  │  11 - экспонента,│ 2.22 77 010 5-308 0<x<1.79 77 010 5308 0 │
 │                  │  52 - мантисса   │                          │
 ├──────────────────┼──────────────────┼──────────────────────────┤
 │long double       │ 310 0 байтов=80 битов│ 3.4 77 010 5-4932 0<x<3.4 77 010 54932 0 │
 └──────────────────┴──────────────────┴──────────────────────────┘

 ш1.2
   Если при вычислениях для переменной типа  float  будет  получено
число с порядком, меньшим -38, оно будет заменено нулём, а если по-
рядок числа превысит 38,  то произойдёт так  называемый  " 1аварийный
 1останов 0" (операционная система прекратит выполнение программы поль-
зователя) и выведено сообщение о переполнении порядка.
   Для переменной типа float число с меньшим порядком,  чем 38, бу-
дет заменено бесконечностью.
   Для переменной типа double нулём являются значения с меньшим по-
рядком, чем -308,  а бесконечностью - значения с порядком  большим,
чем 308.
                      3Описания типа переменной
   Типы всех переменных должны быть описаны до обращения к значени-
ям переменной,  причём каждая переменная должна быть описана только
 1один раз 0.
    _ 1Описание типа переменной . 0 состоит из:
 ш1.1
   (1) одного из следующих  1квалификаторов 0:  short, long, unsigned и
(или)  1спецификатора типа 0: int, char, float, double;
   (2) следующего за ними  1списка идентификаторов 0,  причём идентифи-
каторы в списке разделяются запятыми;
   (3) в конце описания ставится точка с запятой.

 ш1.2
    2Примеры  0( 1описания типа переменной 0).
 ш1.1
   (1) int x;    /* Переменная с идентификатором x имеет тип int */
   (2) unsigned d;  /* Переменная с идентификатором d имеет тип  */
                    /* unsigned int */
   (3) char a,b;    /* Переменные с идентификаторами a и b имеют */
                    /* тип char                                  */
   (4) int count,num;
       char sym;

 ш1.2
   Внутри описания  типа допускается  _ 1инициализация переменных . 0 (т.е.
присваивание им значений):  вслед за идентификатором  располагается
знак равенства и константа, которая в этом случае называется  _ 1иници-
 _ 1ализатором . 0.
    2Пример 0.
 ш1.0

    1Описание типа переменных
      7^            ^
    4┌ 0─── 4┐ 0      4┌ 0───────── 4┐
   int i=0;  char backch='\0';
          7%  0  7              %
         └  1Инициализаторы 0 ┘

 ш1.2
   Для  1описания некоторого идентификатора как имени  типа 0  (другими
словами, для  1создания синонима типа 0) необходимо пользоваться ключе-
вым словом typedef, а более точно, - описанием вида:
 ш1.0

    2typedef 0 < 1Старое имя типа 0> 1  0< 1Новое имя типа 0> 2;

 ш1.2
    2Пример 0.
 ш1.1
   Рассмотрим следующее описание типа:
 ш1.0

   typedef long int lint;

   Благодаря этому такое описание типа, как

   long int x;

может быть представлено в виде

   lint x;
 ш1.2

                     3Понятие о функциях языка C

 ш1.0
                   1Нужно думать не о том, что нам может пригодиться,
                   1а только о том, без чего мы не сможем обойтись. 0
                                                          1Д.К.Джером
 ш1.2

   Выполняемая часть программы на языке C состоит из последователь-
ности определений объектов, которые называются  1функциями 0.
    _ 1Функция . 0 -  это часть программы,  выполняющая некоторые логически
связанные вычисления над данными.
   Функция имеет следующую внутреннюю структуру:
 ш1.1

    1Тип_функции 0  1Имя_функции 0 ( 1Список_параметров 0)
       1Описания_параметров
   {
       1Описания
       1Операторы
   }

 ш1.2
   Круглые скобки после имени обязательны даже при отсутствии  1Спис-
 1ка_параметров 0. В фигурных скобках размещается  _ 1тело функции . 0, которое
включает описания переменных и выполняемые над ними действия.
    _ 1Главной функцией . 0 называется функция с именем main (от англ.  1main
-  1главный 0).
   Программа, написанная на языке C,  всегда начинает выполняться с
функции main(),  поэтому мы имеем возможность  выбирать  имена  для
всех используемых нами функций, кроме той, с которой начинается вы-
полнение программы.  Таким  образом,  функция  main()  должна  быть
единственной в программе.
   В круглых скобках в общем случае содержится информация,  переда-
ваемая  этой  функции;  в случае функции main() передача информации
отсутствует, и, следовательно, скобки пусты.
   Функции могут обращаться к другим функциям посредством некоторой
конструкции, которая называется  _ 1вызовом функции . 0.
   Вызов функции используется при вычислении значения  1выражения 0.
   При вызове функции ей могут быть переданы  аргументы.   1Аргументы
 1передаются  по значению 0 путем копирования в соответствующие (по по-
рядку) параметры, указанные в определении функции.
   Соответствие аргументов и параметров по количеству и типу в язы-
ке C не контролируется.
   В результате вызова функция возвращает вычисленное значение, ко-
торое и является значением вызова функции. Тип значения, возвращае-
мого  функцией,  указывается  в  описании  функции перед её именем.
Иногда тип значения, возвращаемого функцией, можно не указывать.
   Функция может не возвращать значения.  В  этом  случае  действие
функции  заключается  в воздействии на "внешнюю среду" путем вызова
других функций, изменения значений внешних переменных и т.п.
                       3Ввод и вывод в языке С
   Чтобы написать программу,  имеющую смысл,  необходимо уметь вво-
дить исходную информацию и выводить полученные результаты.  В языке
C  имеется  ряд библиотечных функций C,  обеспечивающих стандартную
систему ввода-вывода (таким образом,  в языке C отсутствуют  специ-
альные операторы ввода-вывода).
    _ 1Функциями ввода-вывода . 0 называются функции
 ш1.0

   printf() и scanf().

 ш1.2
   Если Вы желаете воспользоваться функциями ввода-вывода,  то нач-
ните  Вашу  программу  с  _ 1директивы препроцессора . 0 ( 1препроцессор 0 осу-
ществляет некоторую предварительную обработку текста программы  пе-
ред компиляцией):
 ш1.0

   #include <stdio.h>,

 ш1.2
которая подключает к Вашей программе   1файл  стандартных  заголовков
stdio.h,  содержащий  определения библиотечных функций.  В качестве
имени файла используется аббревиатура следующих английских слов:
 ш1.0

    3st 1andar 3d 1  3i 1nput 0/ 3o 1utput  3h 1eader 0,

 ш1.2
(в переводе: " 1стандартный заголовок ввода-вывода 0").
   Таким образом,  функциями ввода-вывода,  1прототипы 0 которых содер-
жатся в stdio.h, можно пользоваться по умолчанию.
    3Замечание 0.
 ш1.1
    21.  0Функции printf() и scanf() - не единственные функции, которы-
ми мы можем воспользоваться для ввода-вывода данных с помощью прог-
рамм на языке C, но они наиболее универсальны.
    22.  0Функции printf() и scanf()  _ 1не входят в описание языка . C 0, поэ-
тому реализация функций ввода-вывода возлагается на создателей ком-
пилятора,   что  даёт  возможность  более  эффективно  организовать
ввод-вывод на конкретных компьютерах.

 ш1.2
                       3Функция вывода printf()
   Для вывода на экран значения переменной необходимо указать  фор-
мат вывода функции printf(), который зависит от типа переменной.
   Приведём форматы, указываемые при обращениях к функции printf(),
а затем покажем, как они используются.
 ш1.0

   ┌──────╥──────────────────────────────────────────────────┐
   │ 3Формат 0║              3Тип выводимой информации  0            │
   ╞══════╬══════════════════════════════════════════════════╡
   │  %c  ║ Символ                                           │
   ├──────╫──────────────────────────────────────────────────┤
   │  %d  ║ Десятичное целое число со знаком                 │
   ├──────╫──────────────────────────────────────────────────┤
   │  %e  ║ Число в экспоненциальном формате                 │
   ├──────╫──────────────────────────────────────────────────┤
   │  %f  ║ Число с фиксированной точкой                     │
   ├──────╫──────────────────────────────────────────────────┤
   │  %g  ║ Наиболее короткий формат из форматов %f или %e;  │
   │      ║ незначащие нули не печатаются                    │
   ├──────╫──────────────────────────────────────────────────┤
   │  %o  ║ Восьмеричное число без знака (без лидирующего 0) │
   ├──────╫──────────────────────────────────────────────────┤
   │  %p  ║ Вывод указателя в шестнадцатеричном формате (эта │
   │      ║ спецификация не входит в стандарт, но она суще-  │
   │      ║ ствует практически во всех реализациях           │
   ├──────╫──────────────────────────────────────────────────┤
   │  %s  ║ Цепочка символов; символы цепочки печатаются до  │
   │      ║ тех пор, пока не будет достигнут нулевой символ  │
   │      ║ или не будет напечатано количество символов, ука-│
   │      ║ занное в спецификации точности                   │
   ├──────╫──────────────────────────────────────────────────┤
   │  %u  ║ Десятичное целое неотрицательное число           │
   ├──────╫──────────────────────────────────────────────────┤
   │  %x  ║ Шестнадцатеричное число без знака (без лидирую-  │
   │      ║ ющих 0x)                                         │
   └──────╨──────────────────────────────────────────────────┘

 ш1.2
   Если после % идет символ, не являющийся символом преобразования,
то он просто выводится на экран.
   Например, сам знак % можно напечатать, задав %%.
   Вызов функции printf() выглядит следующим образом:
 ш1.1

   printf(< 1Управляющая_строка 0>, 1А 41 0, 1А 42 0,...);

 ш1.2
где  1А 41 0, 1А 42 0,...  -  это параметры (аргументы) функции,  которые могут
быть константами, идентификаторами или выражениями;
   < 1Управляющая_строка 0> - это строка символов,  показывающая, каким
образом должны быть выведены на экран параметры:  в ней  содержатся
символы,  выводимые на экран,  и форматы данных, которые называются
 _ 1спецификациями преобразования .. 0  При этом каждому аргументу из спис-
ка,  следующего за управляющей строкой, должна соответствовать  1одна
спецификация преобразования в управляющей строке.
   Например, рассмотрим следующий вызов функции:
 ш1.0

   printf("Значения x=%d, y=%d\n",x,y);

 ш1.2
   Управляющей строкой  здесь является слово в кавычках,  а x и y -
аргументы функции (в данном случае - идентификаторы):
 ш1.0

     1Спецификации преобразования 0   1Аргументы функции printf()
                        7^  0     7^ 0      7^ ^
   printf("Значения x=%d, y=%d \n",x,y);
            4└ 0──────────────────── 4┘
              1Управляющая строка

 ш1.2
   Символы \n не появятся на экране.  Эти символы служат директивой
начать новую строку на устройстве вывода. Комбинация символов \n на
самом деле представляет собой один символ, 1  0называемый  _ 1новая строка . 0.
Для  этого символа не существует соответствующей символьной клавиши
клавиатуры (ему соответствует клавиша  " 1ввод 0").  Его  смысл  кратко
формулируется так: 1   0начать вывод новой строки с самой левой колонки
следующей строки.
   Таким образом, спецификация преобразования %d указывает компиля-
тору, где и в какой форме выводить на экран значения переменных x и
y.  Символы %d служат своего рода "указателем места" в строке выво-
да, куда необходимо поместить значение переменных.
   Каждая спецификация преобразования для функции printf()  начина-
ется с символа % и заканчивается  _ 1символом преобразования . 0:
 ш1.0

   c, d, e, f, g, o, s, u, x.

 ш1.2
   Между % и символом преобразования могут находиться:
 ш1.1
   (1)  1знак минус 0,  указывающий,  что преобразуемый параметр должен
быть выровнен влево в своем поле;
   (2)  1строка цифр 0, задающая минимальный размер поля. Преобразован-
ный параметр будет напечатан в поле минимум указанного размера. Ес-
ли  в преобразованном параметре символов меньше,  чем размещается в
указанном поле,  то слева (справа, если указано выравнивание влево)
будут добавлены пробелы;
   (3)  1строка цифр с начальным нулем 0 - лишние позиции поля заполня-
ются нулями, а не пробелами;
   (4)  1точка 0,  отделяющая размер поля от  последующей  строки  цифр
(только для преобразования строк %s) - строка цифр указывает макси-
мальное число символов, выводимых в одной строке.

 ш1.2
   Перед спецификацией формата могут использоваться  _ 1префиксы специ-
 _ 1фикации . 0 l и h, например
 ш1.0

   %lf, %hu.

   ┌───────┬────────────────┬────────────────────────────┐
   │ 3Префикс 0│ 3Тип спецификации 0│ 3Тип аргумента ввода (вывода) 0│
    3╞═══════ 0╪ 3════════════════ 0╪ 3════════════════════════════ 0╡
    3│ 0   h   │ d, i, o, x, X  │     short int              │
   ├───────┼────────────────┼────────────────────────────┤
   │   h   │       u        │     short unsigned int     │
   ├───────┼────────────────┼────────────────────────────┤
   │   l   │ d, i, o, x, X  │     long int               │
   ├───────┼────────────────┼────────────────────────────┤
   │   l   │       u        │     long unsigned int      │
   ├───────┼────────────────┼────────────────────────────┤
   │   l   │ e, E, f, g, G  │     double (не float!)     │
   └───────┴────────────────┴────────────────────────────┘

 ш1.2
    3Замечание 0.
 ш1.1
   Буква f в имени функции printf() является напоминанием,  что эта
функция осуществляет вывод на экран информации с заданным  1форматом 0.
 ш1.2

                3Работа с демонстрационными примерами

 ш1.0
                   1В сущности всё в конечном счёте сводится к одному
                   1основному моменту - надо практиковаться,  практи-
                   1коваться и практиковаться. 0
                                                           1Д.Карнеги
 ш1.2

 ш1.1
   См. Пример 1, Пример 2, Пример 3, Пример 4, Пример 5, Пример 6.

 ш1.2
                        3Функция ввода scanf()
   Вызов функции scanf(), выглядит следующим образом:
 ш1.1

   scanf(< 1Управляющая_строка 0>,& 1A 41 0,& 1A 42 0,...,& 1A 4n 0);,

 ш1.2
где  1A 41 0, 1A 42 0,..., 1A 4n 0 - это идентификаторы, значения которых надо ввести
с клавиатуры (смысл символа "&" перед именем будет раскрыт ниже);
   < 1Управляющая_строка 0> - это строка символов, которая задает коли-
чество и типы вводимых значений переменных:  в формате  указывается
символ %, за которым следует буква, определяющая тип вводимой пере-
менной.
   При обращении к функции scanf() выполнение программы приостанав-
ливается,  и Вы должны ввести значения для указанных в вызове функ-
ции переменных, после чего работа программы продолжается.
   При вводе  мы будем пользоваться теми же  _ 1спецификациями преобра-
 _ 1зования . 0, которые применялись в функции printf():
 ш1.0

   %c, %d, %e, %f, %g, %o, %s, %u, %x.

 ш1.2
   Спецификации преобразования  должны соответствовать количеству и
типу вводимых значений.
   При применении функции scanf() мы ничего не должны знать о смыс-
ле символа "&" 1. 0  Необходимо запомнить только два правила:  (1) если
Вам необходимо ввести некоторое значение и присвоить его переменной
одного из основных типов,  то перед идентификатором этой переменной
требуется писать символ &; (2) если Вы хотите ввести значение пере-
менной,  значением которого является цепочка символов, то использо-
вать символ & не нужно.
   Управляющая строка функции scanf() может содержать:
 ш1.1
   (1) пробелы ' ',  символы табуляции '\t' и перевода строки '\n',
которые просто игнорируются;
   2) обычные  символы (кроме символа "%"),  которые предполагаются
совпадающими с очередными (отличными от символов,  перечисленных  в
п.(1)) символами входного потока;
   (3) спецификации преобразования,  состоящие из символа "%", нео-
бязательного символа "подавления" присваивания "*", необязательного
числа,  задающего максимальную ширину поля, символа преобразования.
Спецификация преобразования  управляет  преобразованием  очередного
входного поля.  Результат становится значением переменной, на кото-
рый ссылается соответствующий параметр.  Однако,  если присутствует
символ "*", то входное поле просто пропускается, и никакого присва-
ивания не производится.

 ш1.2
                 3Работа с демонстрационными примерами
 ш1.1
   См. Пример 7, Пример 8, Пример 9, Пример 10.

 ш1.2
                    3Функции getchar() и putchar()
    21.  0Функция
 ш1.0

   getchar(),

 ш1.2
не имеющая аргументов,  получает один символ, поступающий с клавиа-
туры, и передаёт его выполняющейся в данный момент функции.
   Например, если функция getchar() получает символ "Q" 2  0(после  на-
жатия  на клавишу "Q"),  то её значением в данный момент будет этот
символ.
    22.  0Функция
 ш1.0

   putchar(),

 ш1.2
имеющая один аргумент,  получает один символ,  поступающий из прог-
раммы,  и пересылает его для вывода на экран. При её вызове необхо-
димо в скобках указать символ, который требуется вывести на экран.
   Аргументом функции putchar() 1  0может быть:
 ш1.1
   -  1символ 0, например: putchar('S');,
   -  1идентификатор 0, например: putchar(ch);,
   -  1функция 0, значением которой является символ, например:
 ш1.0

   putchar(getchar());

 ш1.2
                              3Выражения
    2Определение 0 ( 1содержательное 0).
 ш1.1
    _ 1Выражение . 0 - это комбинация  1операндов 0 и  1операций 0,  задающая поря-
док вычисления некоторого значения.
    _ 1Операции . 0 определяют действия, выполняемые над  1операндами 0.
    _ 1Операнд .  0в  простейшем случае является константой или идентифика-
тором.  Каждый операнд выражения может также представлять собой вы-
ражение, имеющее некоторое значение.

 ш1.2
    2Примеры 0 ( 1выражений 0).
 ш1.1
   4, -6, abc, 4+21, 5*2, ++q%3, a*(b+c/d)/20, q>3.

 ш1.2
   Результат вычисления значения выражения зависит от:
   (1)  1приоритета  операций 0,  который определяет последовательность
выполнения операций в выражении путём группирования операндов;
   (2)  1побочных эффектов 0.
    2Определение 0.
 ш1.1
    _ 1Побочным эффектом при вычислении значения выражения . 0   называется
изменение значения какого-либо операнда, вызванное процессом вычис-
ления значения другого операнда.

 ш1.2
   Для некоторых операций возникновение побочного  эффекта  зависит
от порядка вычисления операндов.

                    3Таблица приоритетов операций

 ш1.0
                                        1Если вы не тот, кто наверху,
                                        1значит, вы тот, кто внизу. 0
                                                       1Стивен Поттер
 ш1.2

    _ 1Таблицей приоритетов операций . 0 назовём следующую таблицу,  указы-
вающую старшинство и порядок выполнения операций:
 ш1.0

  ┌────────────┬────────┬──────────────────────┬──────────────────┐
  │  3Приоритет 0  │ 3Операция 0│         3Название 0      │ 3Порядок выполнения 0│
  ╞════════════╪════════╪══════════════════════╪══════════════════╡
  │   1Высший 0  1  0  │   ()   │ Круглые скобки       │  Слева направо   │
  │            │   []   │ Индекс массива       │  Слева направо   │
  │            │   .    │ Прямая ссылка на эле-│  Слева направо   │
  │            │        │ мент структуры или   │                  │
  │            │        │ объединения          │                  │
  │            │   ─>   │ Ссылка на элемент    │  Слева направо   │
  │            │        │ структуры или объеди-│                  │
  │            │        │ нения с помощью ука- │                  │
  │            │        │ зателя               │                  │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший - 1  0│   +    │ Унарный плюс         │  Слева направо   │
  │            │   -    │ Унарный минус        │  Слева направо   │
  │            1  0│   ++   │ Префиксный инкремент │  Слева направо   │
  │            │   --   │ Префиксный декремент │  Слева направо   │
  │            │   !    │ Логическое отрицание │  Справа налево   │
  │            │   ~    │ Инверсия битов       │  Справа налево   │
  │            │   *    │ Разыменование        │  Справа налево   │
  │            │   &    │ Адрес                │  Справа налево   │
  │            │ ( 1Тип 0)  │ Унарное приведение   │  Справа налево   │
  │            │        │ в стиле C            │                  │
  │            │ sizeof │ Размер объекта       │  Справа налево   │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший - 2 0 │   *    │ Умножение            │  Слева направо   │
  │            │   /    │ Деление              │  Слева направо   │
  │            │   %    │ Остаток              │  Слева направо   │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший - 3 0 │   +    │ Сложение             │  Слева направо   │
  │            │   -    │ Вычитание            │  Слева направо   │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший - 4  0│   >>   │ Поразрядный сдвиг    │  Слева направо   │
  │            │        │ вправо               │                  │
  │            │   <<   │ Поразрядный сдвиг    │  Слева направо   │
  │            │        │ влево                │                  │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший - 5 0 │   >    │ Отношение "больше"   │  Слева направо   │
  │            │   <    │ Отношение "меньше"   │  Слева направо   │
  │            │   >=   │ Отношение "больше или│  Слева направо   │
  │            │        │ равно"               │                  │
  │            │   <=   │ Отношение "меньше или│  Слева направо   │
  │            │        │ равно"               │                  │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший - 6 0 │   ==   │ Отношение "равно"    │  Слева направо   │
  │            │   !=   │ Отношение "не равно" │  Слева направо   │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший - 7 0 │   &    │ Битовое "И"          │  Слева направо   │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший - 8 0 │   ^    │ Битовое исключающее  │  Слева направо   │
  │            │        │ "ИЛИ"                │                  │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший - 9 0 │   |    │ Битовое включающее   │  Слева направо   │
  │            │        │ "ИЛИ"                │                  │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший -10 0 │   &&   │ Логическое "И"       │  Слева направо   │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший -11 0 │   ||   │ Логическое "ИЛИ"     │  Слева направо   │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший -12 0 │   ?:   │ Тернарная условная   │  Справа налево   │
  │            │        │ операция             │                  │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший -13 0 │   =    │ Операция присваивания│  Справа налево   │
  │            │   +=   │ Сложение с присваива-│  Справа налево   │
  │            │        │ нием                 │                  │
  │            │   -=   │ Вычитание с присваи- │  Справа налево   │
  │            │        │ ванием               │                  │
  │            │   *=   │ Умножение с присваи- │  Справа налево   │
  │            │        │ ванием               │                  │
  │            │   /=   │ Деление с присваива- │  Справа налево   │
  │            │        │ нием                 │                  │
  │            │   %=   │ Остаток от деления с │  Справа налево   │
  │            │        │ присваиванием        │                  │
  │            │   &=   │ Поразрядное "И" с    │  Справа налево   │
  │            │        │ присваиванием        │                  │
  │            │   |=   │ Поразрядное "ИЛИ" с  │  Справа налево   │
  │            │        │ присваиванием        │                  │
  │            │   ^=   │ Поразрядное исключаю-│  Справа налево   │
  │            │        │ щее "ИЛИ" с присваи- │                  │
  │            │        │ ванием               │                  │
  │            │   >>=  │ Правый сдвиг с при-  │  Справа налево   │
  │            │        │ сваиванием           │                  │
  │            │   <<=  │ Левый сдвиг с при-   │  Справа налево   │
  │            │        │ сваиванием           │                  │
  ├────────────┼────────┼──────────────────────┼──────────────────┤
  │  1Высший -14 0 │    ,   │ Операция "запятая"   │  Слева направо   │
  └────────────┴────────┴──────────────────────┴──────────────────┘

 ш1.2
   Для изменения порядка действий используйте скобки.

                       3Арифметические операции

 ш1.0
                   1"Четырнадцать", 0  1- сказал Пух.  - "Входите. Четыр-
                   1надцать. Или пятнадцать? Ох. Я совсем запутался" 0.
                                                              1А.Милн
 ш1.2

    _ 1Арифметическими операциями . 0 называются следующие операции:
 ш1.1
   (1) бинарные операции:  1сложение  0(+),  1вычитание  0(или  1бинарный ми-
 1нус 0) (-),  1умножение 0 (*),  1деление 0 (/),  1остаток от деления 0 (%),  1сдвиг
 1влево 0 (<<),  1сдвиг вправо 0 (>>);
   (2) унарные операции:   1операция изменения знака 0 (или  1унарный ми-
 1нус 0) (-),  1операция увеличения  0(++),  1операция уменьшения  0(--).

 ш1.2
   Как обычно в арифметике,  в выражениях операции умножения, деле-
ния и нахождения остатка выполняются  1раньше 0 сложения и вычитания.
   Например 1, 0 результатом вычисления значения выражения 2+3*4-5  яв-
ляется 7  09, результатом вычисления значения выражения 2+3/4-5 являет-
ся -3,  а результатом вычисления значения выражения (2+3)/(4-5) бу-
дет -5.
   В языке C принято следующее  1правило 0:  если  делимое  и  делитель
имеют тип int,  то деление производится нацело,  т.е. дробная часть
результата отбрасывается.
   Существуют две специальные арифметические  операции:   1увеличение
(++)  и   1уменьшение 0  (--).  Слова  "++" или "--" записывается после
идентификатора или перед ним.
   Если знак стоит  1перед 0 идентификатором (в этом случае  говорят  о
 1префиксной  форме 0   1операции 0),  то  вначале  выполняется  увеличение
(уменьшение) значения  идентификатора,  а лишь затем полученный ре-
зультат используется в выражении.
   Если же знак стоит  1после 0 идентификатора ( 1постфиксная форма  опе-
 1рации 0),  то  в выражении используется "старое" значение переменной,
которое затем изменяется.
   Операции увеличения ++ и уменьшения -- можно применять только  к
идентификаторам, например, "выражение" x=(i+j)++ является синтакси-
чески незаконными.
    3Замечание 0.
 ш1.1
    21. 0 Не  применяйте операции увеличения или уменьшения к идентифи-
катору, который входит в выражение более одного раза.
    22. 0 Не  применяйте операции увеличения или уменьшения к идентифи-
катору, присутствующему в более чем одном аргументе функции.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 11, Пример 12, Пример 13, Пример 14, Пример 15,
       Пример 16.

 ш1.2
                                3Квины
    _ 1Квин . 0 ( _ 1самодокументирующаяся программа . 0) - это программа,  которая
генерирует собственный исходный код в качестве выходных данных.
   Приведём несколько квинов,  для написания которых требуется зна-
чительное мастерство программиста:
   (1) один из самых известных квинов [Хэзфилд,Кирби,2001,с.542]
 ш1.0

   char*f="char*f=%c%s%c;main(){printf(f,34,f,34,10);}%c";
   main(){printf(f,34,f,34,10);}

   (2) авторы: В.Таиров и Р.Фахреев

   main(a){printf(a,34,a="main(a){printf(a,34,a=%c%s%c,34);}",34);}

   (3) автор: Р.Овчаров (2 курс, 2002, ноябрь)

#include <iostream.h>
void main()
{
 char i,*a[9]={
 "#include <iostream.h>",
 "void main()",
 "{",
 " char i,*a[9]={",
 " for(i=0;i<4;++i)cout<<a[i]<<(char)10;",
 " for(i=0;i<9;++i)
               cout<<' '<<(char)34<<a[i]<<(char)34<<','<<(char)10;",
 " cout<<' '<<'}'<<';'<<(char)10;",
 " for(i=4;i<9;++i)cout<<a[i]<<(char)10;",
 "};",
 };
 for(i=0;i<4;++i)cout<<a[i]<<(char)10;
 for(i=0;i<9;++i)cout<<' '<<(char)34<<a[i]<<(char)34<<','<<(char)10;
 cout<<' '<<'}'<<';'<<(char)10;
 for(i=4;i<9;++i)cout<<a[i]<<(char)10;
};
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ

 ш1.0
                   1Стало почти традицией в качестве первой программы
                   1на  новом языке программирования писать программу
                   1для вывода на экран терминала чего-нибудь  подоб-
                   1ного приветствию "Hello". 0
                                                            1Г.Джоунз
 ш1.2

    2Пример 0.
 ш1.1
   #include<stdio.h>
   int main()
   {
      int R,C,e;
      int *u;
      for (; printf("\n"),R--,printf("│");)
	 for (e=C; e--; printf("_"+(*u++/8)%2))
           printf("│"+(*u/4)%-2);
      return 0;
   }
 ш1.2

    2Пример 1.
 ш1.1
   /* Демонстрация простейшей программы, написанной на языке C */
   /* -------------------------------------------------------- */
   #include<stdio.h>
   int main()
   {
      printf("Привет,\n математики!\n");
      printf("\"Беги, Спот, беги!\" - сказал Дик.\n");
              /* Для помещения в строку символов символа "кавычка",
                 необходимо поместить перед ним символ "\" */
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Привет, математики!
   "Беги, Спот, беги!" - сказал Дик.

    2Пример 1 41 2.
 ш1.1
   // Демонстрация простейшей программы, написанной на языке C++
   // ----------------------------------------------------------
   #include<iostream.h>
   void main()
   {
      cout << "Привет, математики!\n";
      cout << "\n\"Беги, Спот, беги!\" - сказал Дик.\n";
              // Для помещения в строку символов символа "кавычка",
              // необходимо поместить перед ним символ "\"
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Привет, математики!
   "Беги, Спот, беги!" - сказал Дик.

    2Пример 2.
 ш1.1
   /* Демонстрация инициализации и вывода на экран */
   /* значений типа int с помощью спецификации %d  */
   /* -------------------------------------------- */
   #include<stdio.h>
   int main()
   {
      int z1=12, z2=-88, z3=32789;
      /* ------------------------------------------------------ */
      printf("z1= %d\n",z1);   /* Вывод на экран значений пере- */
      printf("z2= %d\n",z2);   /* менных z1, z2, z3 типа int    */
      printf("z3= %d\n",z3);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   z1= 12
   z2= -88
   z3= -32747
    _ 1Комментарии . 0. Как  уже  отмечалось,  диапазон допустимых значений
типа int - от -32768 до 32767.  Целое число 32789 не входит в  этот
диапазон,  т.к.  превышает максимальное значение на 21. Мы получили
на экране число -32747. Почему?

    2Пример 3.
 ш1.1
   /* Демонстрация инициализации и вывода на экран значений */
   /* типа short int и unsigned int с помощью спецификаций  */
   /* %d и %u                                               */
   /* ----------------------------------------------------- */
   #include<stdio.h>
   int main()
   {
      short int z1=12, z2=-88, z3=32789;
      unsigned int u1=12, u2=65535, u3=32789;
      /* --------------------------------- */
      printf("z1= %d\n",z1);
      printf("z2= %d\n",z2);
      printf("z3= %d\n",z3);
      /* ---------------- */
      printf("u1= %u\n",u1);
      printf("u2= %u\n",u2);
      printf("u3= %u\n",u3);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   z1= 12
   z2= -88
   z3= -32747
   u1= 12
   u2= 65535
   u3= 32789

    2Пример 4 0 (по [Керниган,Ритчи,Фьюер,1985,с.199]) 2.
 ш1.1
   /* Демонстрация инициализации и вывода на экран */
   /* значений типа char с помощью спецификации %c */
   /* -------------------------------------------- */
   #include<stdio.h>
   int main()
   {
      int integer=5,n=-8;
      char character='5';
      /* ----------------------------- */
      printf("character=%d\n",character);      /* 1 */
      printf("character=%c\n",character);      /* 2 */
      printf("integer=%d\n",integer);          /* 3 */
      printf("(integer=53)=%c\n",integer=53);  /* 4 */
      printf("('5'>5)=%d\n",'5'>5);            /* 5 */
      printf("n=%o\n\n",n);                    /* 6 */
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:   _ 1Комментарии . 0.
   character=53                 Печатается код символа '5'.
   integer=5                    Печатается целое число 5.
   character=5                  Печатается значение символа: '5'.
   integer=53=5                 Печатается '5' по его коду - 53.
   ('5'>5)=1                    Печатается 1 ("истина"), т.к. 53>5.
   n=177770                     Печатается восьмеричное число.

    2Пример 5.
 ш1.1
   /* Демонстрация вывода значений типа float и double */
   /* с помощью спецификаций %f, %e, %g                */
   /* ------------------------------------------------ */
   #include<stdio.h>
   int main()
   {
      float z1=2.5,z2=5.67;
      double u1=2.5,u2=5.67;
      /* ------------------------------------------ */
      printf("Результат для типа float : %f\n",z1+z2);
      printf("Результат для типа double: %e\n",u1+u2);
      printf("Самый короткий результат : %g\n",u1+u2);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Результат для типа float : 8.170000
   Результат для типа double: 8.170000e+00
   Самый короткий результат : 8.17

    2Пример 6.
 ш1.1
   /* Демонстрация вывода символьной строки */
   /* с помощью спецификации %s             */
   /* ------------------------------------- */
   #include<stdio.h>
   #include<conio.h> /* Подключение библиотеки ввода-вывода */
                     /* с клавиатуры (для функции getch() ) */
   int main()
   {
      char s[]="Здравствуй, если не шутишь!";
      /* --------------------------------- */
      printf("1. :%s:\n",s);          /* 1 */
      printf("2. :%27s:\n",s);        /* 2 */
      printf("3. :%-27s:\n",s);       /* 3 */
      printf("4. :%32s:\n",s);        /* 4 */
      printf("5. :%-32s:\n",s);       /* 5 */
      printf("6. :%032s:\n",s);       /* 6 */
      printf("7. :%32.16s:\n",s);     /* 7 */
      printf("8. :%-32.16s:\n",s);    /* 8 */
      printf("9. :%.16s:\n",s);       /* 9 */
      getch();       /* Задержка до нажатия клавиши */
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   :Здравствуй, если не шутишь!:
   :Здравствуй, если не шутишь!:
   :Здравствуй, если не шутишь!:
   :     Здравствуй, если не шутишь!:
   :Здравствуй, если не шутишь!     :
   :     Здравствуй, если не шутишь!:
   :                Здравствуй, если:
   :Здравствуй, если                :
   :Здравствуй, если:

    2Пример 7.
 ш1.1
   /* Демонстрация ввода данных с клавиатуры с */
   /* помощью функции scanf()                  */
   /* ---------------------------------------- */
   #include<stdio.h>
   #include<conio.h> /* Подключение библиотеки ввода-вывода */
                     /* с клавиатуры (для функции getch() ) */
   int main()
   {
      int a,b,c,d,e;
      /* ----------------------------------------------------- */
      printf("Вводите пять целых чисел, разделённых пробелом: ");
      scanf("%d%d%d%d%d",&a,&b,&c,&d,&e);
                            /* При вводе каждое число  должно */
                            /* отделяться от другого пробелом */
      printf("\n");
      printf("Результат вывода пяти введённых целых чисел   : ");
      printf("%d %d %d %d %d\n\n",a,b,c,d,e);
      getch();              /* Задержка до нажатия клавиши    */
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   10 20 30 40 50
   10 20 30 40 50

    2Пример 0  28.
 ш1.1
   /* Демонстрация ввода данных с клавиатуры с */
   /* помощью функции scanf()                  */
   /* ---------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      int st,oc;
      /* ----------------------------------------------- */
      printf("Сколько лет Вы изучаете программирование? ");
      scanf("%d",&st);
      printf("Какую оценку Вы получили на экзамене? ");
      scanf("%d",&oc);
      printf("Для того, чтобы прилично изучить язык C, \
              \nВам понадобится %d лет.\n",100/2/st/oc);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Сколько лет Вы изучаете программирование? 1
   Какую оценку Вы получили на экзамене? 2
   Для того, чтобы прилично изучить язык C,
   Вам понадобится 25 лет.

    2Пример 9.
 ш1.1
   /* Демонстрация ввода данных с клавиатуры. Программа */
   /* осуществляет  "сбор и интерпретацию"  сведений  о */
   /* пользователе                                      */
   /* ------------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      int data,month,year;
      char name[15],town[15]; /* Объявление массивов символов */
      /* ---------------------------------------------------- */
      printf("Как Вас зовут? "); scanf("%s",name);
      printf("Укажите дату, месяц и год Вашего рождения.\n");
      printf("Дата (число) : "); scanf("%d",&data);
      printf("Месяц (номер): "); scanf("%d",&month);
      printf("Год          : "); scanf("%d",&year);
      printf("В каком городе родились? "); scanf("%s",town);
      printf("\nВот мы о Вас и узнали кое-что. А именно... \n");
      printf("Вас зовут %s. Вы родились в городе %s (%d.%d.%d)\n",
             name,town,data,month,year);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Как Вас зовут? Иван
   Укажите дату, месяц и год Вашего рождения.
    Дата: 23
   Месяц (число): 02
   Год: 1054
   В каком городе? Новгород
   Вот мы о Вас и узнали кое-что. А именно...
   Вас зовут Иван. Вы родились в городе Новгород (23.2.1054)

    2Пример 10.
 ш1.1
   /* Демонстрация использования символа "*" в функции scanf() */
   /* для подавления вывода: scanf() может прочитать поле вво- */
   /* да, но не присваивать прочитанное значение никакой пере- */
   /* менной; для этого надо перед литерой-спецификатором фор- */
   /* мата поля поставить звездочку "*"                        */
   /* -------------------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      int i,j,k;
      /* ---------------------------- */
      printf("\nВведите числа i,j,k: ");
      scanf("%d %*d %d",&i,&j,&k);
      printf("Результат подавления ввода: i=%d, j=%d, k=%d\n",
             i,j,k);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Введите числа i,j,k: 1 2 3
   Результат подавления ввода: i=1, j=3, k=-29393

    2Пример 11 0 (по [Керниган,Ритчи,Фьюэр,1985,с.194]) 2.
 ш1.1
   /* Демонстрация вычисления значения арифметического выражения */
   /* с использованием приоритетов арифметических операций       */
   /* ---------------------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      int x;
      /* ----------------------------- */
      x=-3+4*5-6;  printf("1. x=%d\n",x);
      x=3+4%5-6;   printf("2. x=%d\n",x);
      x=-3*4%-6/5; printf("3. x=%d\n",x);
      x=(7+6)%5/2; printf("4. x=%d\n",x);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   11  1  0  1
    _ 1Комментарий результатов работы программы . 0.
   Воспользуемся таблицей приоритетов операций,  двигаясь от опера-
ций с высшими приоритетами к операциям с низшими. Будем пользовать-
ся скобками для показа порядка применения операций к операндам.
    _Операция 1 .. x=-3+4*5-6;
   Наивысший приоритет имеет унарная операция "-": x=(-3)+4*5-6.
   Следующий по порядку приоритет имеет операция "*":
   x=(-3)+(4*5)-6.
   Операции "+" и "-" имеют одинаковый приоритет, выполняются спра-
ва налево: сначала "+", потом "-": x=(((-3)+(4*5))-6).
   Операция "=" находится внизу таблицы приоритетов.  Теперь, когда
для каждой операции определены операнды,  можно вычислять  значение
выражения. Вычисление начинается с самого внутреннего подвыражения:
   (x=((-3+(4*5))-6)).
   Заменяем каждое подвыражение на его результат:
   (x=((-3+20)-6)), (x=(17-6)), (x=11), 11.
   Значение выражения, содержащего операцию присваивания, есть зна-
чение правой части выражения,  приведённое к типу левой части прис-
ваивания, т.е. целое число 11.
    _Операция 2 .. x=3+4%5-6;
   Вследствие приоритета операций и порядка их выполнения  получаем
такой результат: (x=((3+(4%5))-6)).
   Вновь вычисление значения выражения начинается "изнутри":
   (x=((3+4)-6), (x=(7-6)), (x=1), 1.
    _Операция 3 .. x=-3*4%-6/5;
   Это выражение сложнее предыдущего, но строгое следование правилу
приоритетов  операций и порядку их выполнения позволяет "распутать"
и его: x=(-3)*4%(-6)/5.
   Операции "*",  "%", "/" имеют один и тот же приоритет и выполня-
ются слева направо:
 ш1.0

   x=((-3)*4)%(-6)/5
   x=((-3)*4)%(-6)/5
   x=(((-3)*4)%(-6))/5
   x=((((-3)*4)%(-6))/5)
   (x=((((-3)*4)%(-6))/5))

 ш1.2
   Начинаем изнутри вычислять значение выражения:
   (x=(((-3*4)%-6)/5)), (x=((-12%-6)/5)), (x=(0/5)), (x=0), 0.
    _Операция 4 .. x=(7+6)%5/2;
   Мы не всегда жёстко связаны с  заранее  известными  приоритетами
операций; если порядок выполнения нужно изменить или просто "прояс-
нить" структуру выражения, то используются скобки.
   Вначале вычисляются подвыражения в скобках. Далее следуем прави-
лу приоритетов операций и порядку их выполнения:
 ш1.0

   x=((7+6)%5)/2
   x=(((7+6)%5)/2)
   (x=(((7+6)%5)/2))

 ш1.2
   Начинаем изнутри вычислять выражение:
   (x=(13%5)/2), (x=(3/2)), 1.
   Так как  при  операциях  с целыми числами дробная часть операнда
отбрасывается,  то на следующем шаге вычислений получаем  выражение
(x=1), значением которого является 1.

    2Пример 12.
 ш1.1
   /* Демонстрация вычисления результатов совместного выполнения:*/
   /* (а) операции уменьшения и операции вычитания;              */
   /* (б) операции увеличения (уменьшения) и операции сложения   */
   /* ---------------------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      int a=1, b=2, c;
      /* --------------------------------------------------- */
      printf("1. a=%2d, b=%2d, c=a---b;     => ",a,b); getch();
      c=a---b;
      printf("a=%2d, b=%2d, c=%2d\n",a,b,c);
      /* --------------------------------------------------- */
      printf("2. a=%2d, b=%2d, c=a---(--b); => ",a,b); getch();
      c=a---(--b);
      printf("a=%2d, b=%2d, c=%2d\n",a,b,c);
      /* --------------------------------------------------- */
      printf("3. a=%2d, b=%2d, c=a+++b;     => ",a,b); getch();
      c=a+++b;
      printf("a=%2d, b=%2d, c=%2d\n",a,b,c);
      /* --------------------------------------------------- */
      printf("4. a=%2d, b=%2d, c=a+++(--b); => ",a,b); getch();
      c=a+++(--b);
      printf("a=%2d, b=%2d, c=%2d\n\n",a,b,c);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   a=1, b=2, c=a---b; => a=0, b=2, c=-1
   a=0, b=2, c=a---(--b); => a=-1, b=1, c=-1
   a=-1, b=1, c=a+++b; => a=0, b=1, c=0
   a=0, b=1, c=a+++(--b); => a=1, b=0, c=0

    2Пример 13.
 ш1.1
   /* Демонстрация арифметических операций над типом int   */
   /* (short int). Диапазон значений типа int (short int): */
   /* целые числа из [-32768,32767]                        */
   /* ---------------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      int a,b,c=5,d=32789;
      /* ----------------------------------------- */
      printf("Введите значение a: "); scanf("%d",&a);
      printf("Введите значение b: "); scanf("%d",&b);
      printf("1. a=%d, b=%d, c=%d, d=%d\n",a,b,c,d);
      printf("2. a*b=%d, c%%a=%d\n",a*b,c%a);
      printf("3. ++b=%d\n",++b); b=5;
      printf("4. b=%d, c=%d\n",b,c);
      printf("5. b=%d, b--=%d, b=%d\n",b,b--,b);
      printf("6. c=%d, ",c); printf("c--=%d, ",c--);
      printf("c=%d\n\n",c);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Введите значение a: 1
   Введите значение b: 2
   c=5, a*b=2, c%a=0, ++b=3, c--=5, c=4, d=-32747

    2Пример 0  213 41 2.
 ш1.1
   /* Демонстрация операций над типом unsigned int.   */
   /* Диапазон значений типа unsigned int: целые чис- */
   /* ла из [0,65535].                                */
   /* Над данными типа unsigned int допустимы те же   */
   /* операции, что и над типом int                   */
   /* ----------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      unsigned int x,y,d=32789;
      /* ----------------------------------------- */
      printf("Введите значение x: "); scanf("%u",&x);
      printf("Введите значение y: "); scanf("%u",&y);
      printf("x=%u, y=%u, d=%u\n",x,y,d);
      printf("x+(++y)=%u\n",x+(++y));
      printf("x-y=%u\n",x-y);
      printf("(x==y)=%d\n",x==y);
      printf("(x!=y)=%d\n",x!=y);
      d=65537; printf("d=%u\n",d);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Введите значение x: 1
   Введите значение y: 2
   x=1, y=2, d=32789
   x+(++y)=4
   x-y=65534
   x==y=0
   x!=y=1
   d=1

    2Пример 14.
 ш1.1
   /* Демонстрация операций над типом char.           */
   /* Демонстрация функций getchar() и putchar().     */
   /* ----------------------------------------------- */
   /* Тип данных char определяет множество символов с */
   /* кодами ASCII. Над данными типа char допустимы   */
   /* следуюшие операции:                             */
   /* (1) сравнения (==, !=);                         */
   /* (2) операции с кодом символа                    */
   /* ----------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      int t=3;
      char b,
           m='R';
      /* ------------------------------------------- */
      printf("\nВведите значение b: "); scanf("%c",&b);
      printf("m=%c\n",m);
      printf("Код символа %c равен %d\n",b,(int)b);
      printf("Код символа %c равен %d\n",m,m);
      printf("t=%d\n",t);
      printf("t+(int)b=%d\n",t+=(int)b);
      printf("Символ с кодом %d - это %c\n",t,(char)t);
      /* ------------------------------------------------- */
      printf("Познакомимся с функциями getchar и putchar\n");
      fflush(stdin); /* Очистка буфеpа клавиатуpы */
      printf("Введите символ: "); b=getchar();
      printf("Вот Ваш символ: "); putchar(b);
      printf("\n");
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Введите значение b: A
   m=R
   Код символа A равен 65
   Код символа R равен 82
   t=3
   t+(int)b=68
   Символ с кодом 68 - это D
   Познакомимся с функциями getchar() и putchar()
   Введите символ: d
   Вот Ваш символ: d

    2Пример 15.
 ш1.1
   /* Демонстрация операций над типом float.                   */
   /* Диапазон значений типа float: [3.4*10^(-38),3.47*10^38]. */
   /* Над данными типа float допустимы следующие операции:     */
   /*                                                          */
   /* (1) арифметические операции:                             */
   /*     - сложение (+);                                      */
   /*     - вычитание (-);                                     */
   /*     - умножение (*);                                     */
   /*     - деление (/);                                       */
   /*     - изменение знака (-);                               */
   /*                                                          */
   /* (2) сравнения (==, !=, <=, <, >=, >,)                    */
   /* -------------------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      float a,b=5.e-2,c=6.e-6,d=-4.e39;
      int r=3;
      /* ---------------------------------------- */
      printf("\nВведите число a: "); scanf("%f",&a);
      printf("1. b=%f c=%f\n",b,c);
      printf("2. a+b=%f\n",a+b);
      printf("3. b*c=%e\n",b*c);
      printf("4. d=%f\n",d);
      printf("5. r=%d\n",r);
      printf("6. ++r*c=%f\n",++r*c);
      printf("7. a<=b  %d\n",a<=b);
      printf("8. a>b   %d\n\n",a>b);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Введите число a: 10
   b=0.050000
   c=0.000006
   a+b=10.050000
   b*c=3.000000e-07
   d=-INF
   r=3
   ++r*c=0.000024
   a<=b  0
   a>b   1

    2Пример 16.
 ш1.1
   /* Демонстрация операций над типом double.                   */
   /* Диапазон значений типа double: [1.7*10^(-308),1.7*10^308].*/
   /* Над данными типа double допустимы те же операции, что     */
   /* и над данными типа float.                                 */
   /* При вводе значения переменной с клавиатуры и  выводе  на  */
   /* экран значения переменной типа double можно использовать  */
   /* символы преобразования %lf и %le                          */
   /* --------------------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   int main()
   {
      double s,t,r=3.4e-16;
      float n=6.e-15;
      int k=2;
      /* --------------------------------------- */
      printf("Введите число t: "); scanf("%le",&t);
      printf("1. r=%e, n=%e, k=%d\n",r,n,k); s=r+n;
      printf("2. r+n=%e\n",s); t+=k; 
      printf("3. Выполнили операцию t+=k. Теперь t=%e\n\n",t);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
   Введите число t: 18.009
   r=3.400000e-16
   n=6.000000e-15
   k=2
   r+n=6.340000e-15
   Выполнили операцию t+=k. Теперь t=2.000900e+01

    2Пример 17 0 [Тондо,Гимпел,1994,с.34] 2.
 ш1.1
   /* Демонстрация определения диапазона типов с помощью */
   /* предопределённых констант                          */
   /* -------------------------------------------------- */
   #include<stdio.h>
   #include<conio.h>
   #include<limits.h>
   int main()
   {
      /* Беззнаковые типы */
      printf("unsigned char max=%d\n",UCHAR_MAX);
      printf("unsigned short max=%ld\n",USHRT_MAX);
      printf("unsigned int max=%ld\n",UINT_MAX);
      printf("unsigned long max=%lu\n\n",ULONG_MAX);
      /* Знаковые типы */
      printf("signed char min=%d\n",SCHAR_MIN);
      printf("signed char max=%d\n",SCHAR_MAX);
      printf("signed short min=%d\n",SHRT_MIN);
      printf("signed short max=%d\n",SHRT_MAX);
      printf("signed int min=%d\n",INT_MIN);
      printf("signed int max=%d\n",INT_MAX);
      printf("signed long min=%ld\n",LONG_MIN);
      printf("signed long max=%ld\n\n",LONG_MAX);
      getch();
      return 0;
   }

 ш1.2
    _ 1Результат работы программы . 0:
 ш1.0

   unsigned char max=255
   unsigned short max=65535
   unsigned int max=65535
   unsigned long max=4294967295

   signed char min=-128
   signed char max=127
   signed short min=-32768
   signed short max=32767
   signed int min=-32768
   signed int max=32767
   signed long min=-2147483648
   signed long max=2147483647
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                      1Львица обучает детенышей без церемоний, львята
                      1прыгают, а львица сбивает их наземь. 0
                             1Из древнего китайского сборника 0  1"Умэнь.
                             1Застава без ворот" (XII в.)
 ш1.2

    21. 0 По данным сторонам прямоугольника вычислите  его  периметр  и
площадь квадрата со стороной, длина которой равна сумме длин сторон
данного прямоугольника.
    22. 0 Вычислите объём цилиндра с радиусом основания 5 см и  высотой
10 см.
    23. 0 Вычислите косинус угла при вершине A в треугольнике ABC, если
известны его стороны: a=5, b=3, c=7.
    24. 0 Определите  расстояние,  пройденное физическим телом за время
t=3 с,  если тело движется с постоянным ускорением а=4 м/c 52 0 и имеет
в начальный момент времени скорость v 40 0=5 м/с.
    25. 0 Дано натуральное число n, n<100. Найдите его последнюю цифру.
    26. 0 Вычислите сумму цифр данного двузначного натурального числа.
    27. 0 Вычислите значение функции z=f(x,y) по введённым с клавиатуры
вещественным числам x и y:
 ш1.1
   (1) f(x,y)=x+y-2;        (6) f(x,y)=(x+y)/2;
   (2) f(x,y)=y*x 52 0+5*x-2;  5  0 (7) f(x,y)=(x+y)*(x-y);
   (3) f(x,y)=у*x;          (8) f(x,y)=(x-y)*(x 52 0+x*y+y 52 0);
   (4) f(x,y)=(y-x)*(y-x);  (9) f(x,y)=(x+y)/(x-y)+(x-y)/(x+y);
   (5) f(x,y)=x/y;          (10) f(x,y)=y+1+x+x 52 0/2+x 53 0/6+x 54 0/24.

 ш1.2
    28. 0 Объясните результат работы следующих программ:
 ш1.0

   (1) #include<stdio.h>
       void main()
       {
          char c1,c2,c3;
          c1='1'; c2='2'; c3='3';
          printf("Код символа %c равен %d\n",c1,(int)c1);
          printf("Код символа %c равен %d\n",c2,(int)c2);
          printf("Код символа %c равен %d\n",c3,(int)c3);
          printf("Сумма кодов = %d",(int)c1+(int)c2+(int)c3);
       }

   (2) #include<stdio.h>
       void main()
       {
          char c1,c2,c3;
          c1='1'; c2='2'; c3='3';
          printf("Код символа %c равен %d\n",c1,c1);
          printf("Код символа %c равен %d\n",c2,c2);
          printf("Код символа %c равен %d\n",c3,c3);
          printf("Сумма кодов = %d",c1+c2+c3);
       }

   (3) #include<stdio.h>
       void main()
       {
          int x,y,z,k;
          x=2; x*=3+2; printf("x=%d\n",x);
          x*=y=z=4; printf("x=%d\n",x);
          x=y==z; printf("x=%d\n",x);
          k=x==(y=z); printf("k=%d,x=%d\n",k,x);
       }

 ш1.2
    29. 0 В  приведённых  ниже программах замените символы "???" на до-
пустимые символы преобразования:
 ш1.0

   (1) #include<stdio.h>
       void main()
       {
          int x,y,z;
          printf("Введите значение X: "); scanf("???",&x);
          printf("Введите значение Y: "); scanf("???",&y);
          z=x+y; printf("Значение Z: ???",z);
       }

   (2) #include<stdio.h>
       void main()
       {
         int z1,z2,z3;
         z1=12; z2=-88; z3=32789;
         printf("z1= ???\n",z1);
         printf("z2= ???\n",z2);
         printf("z3= ???\n",z3);
       }

   (3) #include<stdio.h>
       void main()
       {
          unsigned int z1,z2,z3;
          z1=12; z2=65535; z3=32789;
          printf("z1= ???\n",z1);
          printf("z2= ???\n",z2);
          printf("z3= ???\n",z3);
       }

   (4) #include<stdio.h>
       void main()
       {
          int data,month,year;
          char name[15],town[15];
          printf("Как Вас зовут? "); scanf("%s",name);
          printf("Укажите число, месяц и год рождения.\n Число: ");
          scanf("???",&data);
          printf("Месяц (числом): "); scanf("???",&month);
          printf("Год: "); scanf("???",&year);
          printf("А в каком городе? "); scanf("%s",town);
          printf("Вот мы о Вас и узнали кое-что. А именно: \n");
          printf("Вас зовут %s ",name);
          printf("Вы родились в городе %s (???.???.???)",
                 town,data,month,year);
       }

 ш1.2
    210. 0 Вербально опишите алгоритм,  реализованный в программе, при-
ведённой ниже.
 ш1.0

   #include<stdio.h>
   void main()
   {
      int x,a,b,c;
      printf("Введите целое положительное трёхзначное число: ");
      scanf("%d",&x); a=x/100; x=x-a*100; b=x/10; x=x-b*10; c=x;
      printf("%d",a+b+c);
   }

    211 5* 2. 0 Опишите вербально назначение приведённой ниже программы:

   #include<stdio.h>
   #include<math.h>  /* Подключение библиотеки, содержащей */
                     /* математические функции             */
   void main()
   {
      float z1,z2;
      double z3,z4;
      printf("***=%e\n",M_E); printf("***=%e\n",M_PI);
      printf("Введите число z1: "); scanf("%e",&z1);
      printf("Введите число z2: "); scanf("%e",&z2);
      printf("Результат: %e\n",sin(z1));
      printf("Результат: %e\n",cos(z1));
      printf("Результат: %e\n",sqrt(z2));
      printf("Результат: %e\n",pow(z1,z2));
      /* ----------------------------------------- */
      printf("Введите число z3: "); scanf("%le",&z3);
      printf("Введите число z4: "); scanf("%le",&z4);
      printf("Результат: %le\n",sin(z3));
      printf("Результат: %le\n",cos(z3));
      printf("Результат: %le\n",sqrt(z4));
      printf("Результат: %le\n",pow(z1,z4));
   }

 ш1.2
    211 41 2. 0 (По [Кашаев,2010,с.52-55])
   В приведённых ниже программах используются действия  над  целыми
числами. Определите:
   (1) значения переменных a и b
 ш1.0

   #include<stdio.h>
   #include<conio.h>
   void main()
   {
      int a,b;
      a=3+8*4; b=a%10+14; a=b%10+2;
      printf("Значение переменной а=%d\n",a);
      printf("Значение переменной b=%d\n",b);
      getch();
   }

   (2) значения переменных a и b

   #include<stdio.h>
   #include<conio.h>
   void main()
   {
      int a,b;
      b=a/100*10+9; a=(10*b-a)%100;
      printf("Значение переменной а=%d\n",a);
      printf("Значение переменной b=%d\n",b);
      getch();
   }

   (3) значение переменной a

   #include<stdio.h>
   #include<conio.h>
   void main()
   {
      int a=1,b=9;
      a=-a+b*2; a=4*a%10;
      printf("Значение переменной а=%d\n",a);
      getch();
   }

   (4) результат работы программы

   #include<stdio.h>
   #include<conio.h>
   void main()
   {
      int a=1;
      a=a*200;
      printf(" %d\n",a);
      printf("%d%d%d\n",a,a,a);
      getch();
   }

   (5) результат работы программы

   #include<stdio.h>
   #include<conio.h>
   void main()
   {
      int a=1;
      a=a*200;
      printf(" %d %d\n",a,a);
      printf("%5d%7d%2d\n",a,a,a);
      getch();
   }

 ш1.2
    211 42 2. 0 (По [Кашаев,2010,с.56-59])
   Для приведённых ниже программ определите результат работы:
 ш1.0

   (1) #include<stdio.h>
       #include<conio.h>
       #include<math.h>
      /* ------------ */
       void main()
       {
          double n=2;
          n=pow(n,3); n=sqrt(n)*sqrt(n);
          printf("n=%g\n",n);
          getch();
       }

   (2) #include<stdio.h>
       #include<conio.h>
       void main()
       {
          double z,w,x;
          w=2*2.54; z=1.15; x=w-2*z;
          printf("сумма = %g\n",x);
          getch();
       }

   (3) #include<stdio.h>
       #include<conio.h>
       #include<math.h>
      /* ------------ */
       void main()
       {
          double m=-6;
          m=sqrt(fabs(m)+floor(M_PI));
          printf("m=%g\n",m);
          getch();
       }

 ш1.2
    212 5** 0. Напишите свой собственный  1квин 0.
                        3Программы с ошибками
    21. 0 (По [Уэллин,2004,с.31])
   Найдите ошибку в приведённых ниже программах:
   (1) на языке программирования C:
 ш1.0

   /* Практически все книги по программированию начинаются  */
   /* с программы, выводящей на экран текст "Hello World".  */
   /* Как можно "сломать" нечто настолько элементарное, как */
   /* такую программу? Посмотрите сами...                   */
   /* ----------------------------------------------------- */
   #include<stdio.h>
   void main()
   {
      printf("Hello World/n");
   }

   (б) на языке программирования C++:

   // Практически все книги по программированию начинаются
   // с программы, выводящей на экран текст "Hello World".
   // Как можно "сломать" нечто настолько элементарное, как
   // такую программу? Посмотрите сами
   // --------------------------------
   #include<iostream.h>
   int main()
   {
      cout << "Hello World/n";
      return 0;
   }
 ш1.2
